<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¥åº·å¤§å¸«ï¼šä»£è¬ä¹‹æˆ° - å†’éšªç¯‡</title>
    <!-- Pixel font for English/Numbers -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #202020;
            --text-color: #333;
            --ui-bg: #f8f9fa;
            --ui-border: #4a4a4a;
            --hp-green: #48c075;
            --hp-yellow: #f5ac38;
            --hp-red: #e64e4e;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            /* Updated Font Stack: Prioritizes Pixel font for English, then standard Chinese fonts for different OS */
            font-family: 'Press Start 2P', 'Microsoft JhengHei', 'PingFang TC', 'Heiti TC', 'LiHei Pro', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: var(--text-color);
            overflow: hidden;
        }

        #game-boy {
            width: 100%;
            max-width: 800px;
            height: 98vh; /* Maximize height usage */
            background: #d0d0d0;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            font-size: 16px;
        }

        /* Battle Scene Layer */
        #battle-scene {
            flex: 2; /* Give more space to battle scene */
            background-size: cover;
            background-position: center bottom;
            position: relative;
            transition: background 0.5s; /* Smooth transition for gradients */
            overflow: hidden;
            border-bottom: 4px solid #333;
        }
        
        /* CSS Gradients for reliable backgrounds */
        .bg-forest { 
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 65%, #228B22 65%, #228B22 100%);
        } 
        .bg-city { 
            background: linear-gradient(to bottom, #2c3e50 0%, #34495e 60%, #7f8c8d 60%, #95a5a6 100%);
        }
        .bg-gym { 
            background: linear-gradient(to bottom, #f1c40f 0%, #f39c12 70%, #d35400 70%, #e67e22 100%);
        }

        /* Platforms - Adjusted positions */
        .platform {
            position: absolute;
            width: 220px;
            height: 70px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            transform: scaleY(0.4);
            filter: blur(8px);
        }
        #enemy-platform { top: 35%; right: 10%; }
        #player-platform { bottom: 20%; left: 10%; }

        /* Sprites - Adjusted to be safer within viewport */
        .sprite {
            position: absolute;
            image-rendering: pixelated;
            transition: filter 0.2s, transform 0.2s, opacity 0.5s;
            opacity: 0;
            display: block;
            object-fit: contain; /* Ensure image fits in box */
        }
        
        #enemy-sprite {
            top: 15%; 
            right: 12%; 
            height: 140px; /* Slightly smaller to prevent clipping */
            width: 140px;
            z-index: 10;
        }

        #player-sprite {
            bottom: 22%; 
            left: 12%; 
            height: 160px; /* Slightly smaller to prevent clipping */
            width: 160px;
            z-index: 20;
        }

        /* Animations */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-10px); filter: brightness(2) sepia(1) hue-rotate(-50deg) saturate(5); } 
            50% { transform: translateX(10px); }
            75% { transform: translateX(-10px); }
            100% { transform: translateX(0); filter: none;}
        }

        @keyframes attack-lunge {
            0% { transform: translate(0, 0); }
            50% { transform: translate(30px, -30px); }
            100% { transform: translate(0, 0); }
        }

        @keyframes enemy-lunge {
            0% { transform: translate(0, 0); }
            50% { transform: translate(-30px, 30px); }
            100% { transform: translate(0, 0); }
        }

        @keyframes faint {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(50px); opacity: 0; }
        }

        .anim-shake { animation: shake 0.5s; }
        .anim-attack-p { animation: attack-lunge 0.3s; }
        .anim-attack-e { animation: enemy-lunge 0.3s; }
        .anim-faint { animation: faint 1s forwards; }

        /* HUD */
        .hud-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 4px solid #333;
            border-radius: 12px 2px 12px 2px;
            padding: 12px;
            width: 280px;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.2);
            transition: opacity 0.3s;
            z-index: 30;
        }

        #enemy-hud { top: 20px; left: 20px; }
        #player-hud { bottom: 20px; right: 20px; }

        .name-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 8px; font-weight: bold; }
        .hp-container {
            width: 100%;
            height: 16px;
            background: #ddd;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .hp-bar {
            height: 100%;
            background: var(--hp-green);
            width: 100%;
            transition: width 0.5s ease-out, background-color 0.3s;
        }
        .hp-text { font-size: 12px; text-align: right; margin-top: 6px; font-weight: bold; }
        
        .status-badges { display: flex; gap: 5px; margin-top: 8px; flex-wrap: wrap; }
        .badge { font-size: 10px; padding: 4px 6px; color: white; border-radius: 4px; text-shadow: 1px 1px 0 #000; }

        /* UI Layer */
        #ui-layer {
            height: 280px; /* Fixed height for controls */
            flex-shrink: 0;
            background: #222;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 6px solid #f8d030;
            position: relative;
        }

        #dialogue-box {
            background: #3a3a3a;
            color: white;
            border: 4px solid #fff;
            border-radius: 8px;
            padding: 15px;
            height: 100px;
            font-size: 16px;
            line-height: 1.5;
            position: relative;
            cursor: pointer;
            overflow-y: hidden;
        }
        #dialogue-box::after {
            content: 'â–¼';
            position: absolute;
            bottom: 10px;
            right: 10px;
            animation: bounce 1s infinite;
            font-size: 20px;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(5px); } }

        #controls {
            display: flex;
            height: 120px;
            gap: 10px;
            position: relative;
        }

        #main-menu, #move-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
            height: 100%;
        }

        .btn {
            background: #f8f9fa;
            border: 4px solid #4a4a4a;
            border-radius: 8px;
            /* Updated Font Stack for buttons as well */
            font-family: 'Press Start 2P', 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 5px;
            position: relative;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #bbb;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 0 #bbb; }
        .btn:hover { background: #e8e8e8; border-color: #e64e4e; }
        
        .move-type-icon { font-size: 10px; opacity: 0.7; margin-top: 5px; }

        #move-menu { display: none; }

        /* Party Menu Overlay */
        #party-menu {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(30, 30, 30, 0.95);
            padding: 20px;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
            overflow-y: auto;
        }
        
        .party-title { color: white; font-size: 18px; margin-bottom: 10px; text-align: center;}

        .party-slot {
            background: white;
            border: 4px solid #555;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            height: 70px;
        }
        .party-slot:hover { border-color: #e64e4e; background: #fff5f5; }
        .party-slot.fainted { background: #ccc; opacity: 0.7; }
        .party-slot.active { border-color: #48bb78; background: #f0fff4; }

        .party-info { font-size: 12px; flex: 1; margin-left: 15px; font-weight: bold; }
        .party-hp-mini { width: 100px; height: 8px; background: #eee; border: 2px solid #333; margin-top: 5px; border-radius: 5px; }
        .party-hp-fill { height: 100%; background: #48c075; width: 100%; }

        /* Canvas Overlay for Particles */
        #fx-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 40;
        }

        /* Loading Screen */
        #loader {
            position: absolute;
            top:0; left:0; width:100%; height:100%;
            background: #202020;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 20px;
            text-align: center;
            line-height: 1.5;
        }
        .spinner { width: 50px; height: 50px; border: 5px solid #fff; border-top-color: transparent; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px;}
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
</head>
<body>

<div id="game-boy">
    <div id="loader">
        <div class="spinner"></div>
        <div>æ­£åœ¨é€£æ¥ PokÃ©API...</div>
        <div style="font-size: 14px; margin-top: 15px; color:#aaa;">æº–å‚™å¥åº·çŸ¥è­˜è³‡æ–™åº«<br>å»ºç«‹å¼±é»åˆ†ææ¨¡å‹</div>
    </div>

    <canvas id="fx-canvas"></canvas>

    <div id="battle-scene" class="bg-forest">
        <!-- HUDs -->
        <div id="enemy-hud" class="hud-box" style="opacity:0;">
            <div class="name-row">
                <span id="e-name">Loading...</span>
            </div>
            <div class="hp-container">
                <div id="e-hp-bar" class="hp-bar"></div>
            </div>
            <div class="status-badges" id="e-badges"></div>
        </div>

        <div id="player-hud" class="hud-box" style="opacity:0;">
            <div class="name-row">
                <span id="p-name">Loading...</span>
            </div>
            <div class="hp-container">
                <div id="p-hp-bar" class="hp-bar"></div>
            </div>
            <div class="hp-text"><span id="p-hp-cur">100</span> / <span id="p-hp-max">100</span></div>
            <div class="status-badges" id="p-badges"></div>
        </div>

        <div class="platform" id="enemy-platform"></div>
        <!-- Simplified onerror to ensure visibility even if broken icon -->
        <img id="enemy-sprite" class="sprite" src="" alt="Enemy" onerror="this.onerror=null; this.src='https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png';">
        
        <div class="platform" id="player-platform"></div>
        <!-- Simplified onerror -->
        <img id="player-sprite" class="sprite" src="" alt="Player" onerror="this.onerror=null; this.src='https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png';">
    </div>

    <div id="ui-layer">
        <div id="dialogue-box" onclick="battle.advanceText()">
            æ­£åœ¨åˆå§‹åŒ–å†’éšª...
        </div>

        <div id="controls">
            <!-- Main Actions -->
            <div id="main-menu">
                <button class="btn" onclick="battle.toMoveMenu()">âš”ï¸ æˆ°é¬¥</button>
                <button class="btn" onclick="battle.showBag()">ğŸ’ èƒŒåŒ…</button>
                <button class="btn" onclick="battle.openPartyMenu(false)">ğŸ‘¥ ç²¾éˆ</button>
                <button class="btn" onclick="battle.run()">ğŸƒ é€ƒè·‘</button>
            </div>

            <!-- Moves -->
            <div id="move-menu">
                <!-- Injected via JS -->
            </div>

            <!-- Party Selection Overlay -->
            <div id="party-menu">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>
</div>

<script>
/**
 * Configuration & Data
 */
const PLAYER_CONFIG = [
    { id: 68, name: "æ€ªåŠ› (é‹å‹•)", role: "fighting", customMoves: ["Cross Chop", "Vital Throw", "Strength", "Bulk Up"] },
    { id: 154, name: "å¤§ç«ºè‘µ (çº–ç¶­)", role: "grass", customMoves: ["Giga Drain", "Synthesis", "Petal Dance", "Sunny Day"] },
    { id: 9, name: "æ°´ç®­é¾œ (æ°´åˆ†)", role: "water", customMoves: ["Hydro Pump", "Aqua Ring", "Rain Dance", "Protect"] },
    { id: 448, name: "è·¯å¡åˆ©æ­ (æ„å¿—)", role: "fighting", customMoves: ["Aura Sphere", "Calm Mind", "Close Combat", "Quick Attack"] }
];

const STAGES = [
    {
        name: "ç¬¬ä¸€é—œï¼šç³–æœæ£®æ—",
        bg: "bg-forest",
        intro: "ç©ºæ°£ä¸­ç€°æ¼«è‘—ç”œè†©çš„å‘³é“...\nå°å¿ƒï¼ç³–ç™®æœƒå°è‡´èƒ°å³¶ç´ é˜»æŠ—ï¼",
        enemyConfig: { id: 584, name: "é›™å€å¤šå¤šå†° (ç³–ç™®)", role: "sugar", customMoves: ["Icicle Crash", "Sweet Scent", "Avalanche", "Blizzard"] }
    },
    {
        name: "ç¬¬äºŒé—œï¼šæ²™ç™¼å±±è°·",
        bg: "bg-gym",
        intro: "é€™è£¡çš„å±…æ°‘æ•´å¤©èººè‘—ä¸å‹•...\nä¹…åæ˜¯è¬ç—…ä¹‹æºï¼",
        enemyConfig: { id: 143, name: "å¡æ¯”ç¸ (ä¹…å)", role: "lazy", customMoves: ["Yawn", "Rest", "Body Slam", "Snore"] }
    },
    {
        name: "ç¬¬ä¸‰é—œï¼šåƒåœ¾æ©åŸ‹å ´",
        bg: "bg-city",
        intro: "å……æ»¿äº†åŠ å·¥é£Ÿå“å’Œæ²¹ç‚¸å‘³...\nåƒåœ¾é£Ÿç‰©æœƒé€ æˆèº«é«”ç™¼ç‚ï¼",
        enemyConfig: { id: 89, name: "è‡­è‡­æ³¥ (æ¯’ç´ )", role: "junk", customMoves: ["Sludge Bomb", "Gunk Shot", "Toxic", "Belch"] }
    }
];

const HEALTH_TYPE_CHART = {
    'lazy': { 'fighting': 2.0, 'grass': 0.5, 'water': 0.5 },
    'sugar': { 'water': 2.0, 'grass': 2.0, 'fighting': 1.0 },
    'junk': { 'grass': 2.0, 'water': 1.5, 'fighting': 1.0 }
};

const EDU_TEXT = {
    // --- Player Moves (Health Advice) ---
    "cross-chop": "äº¤å‰è¨“ç·´èƒ½å…¨é¢æå‡å¿ƒè‚ºèˆ‡è‚Œè€åŠ›ï¼",
    "vital-throw": "æ ¸å¿ƒè‚Œç¾¤æ˜¯èº«é«”ç©©å®šçš„é—œéµï¼Œé¿å…å—å‚·ï¼",
    "strength": "è² é‡é‹å‹•èƒ½å¢åŠ éª¨è³ªå¯†åº¦ï¼Œé é˜²éª¨æŠ˜ã€‚",
    "bulk-up": "å¢åŠ è‚Œè‚‰é‡å¯æå‡åŸºç¤ä»£è¬ç‡ï¼Œèººè‘—ä¹Ÿç‡ƒè„‚ï¼",
    
    "giga-drain": "å¤šåƒåŸå‹é£Ÿç‰©ï¼Œæ¸›å°‘ç²¾ç·»æ¾±ç²‰æ”å–ã€‚",
    "synthesis": "å‡è¡¡é£²é£ŸåŒ…å«å…¨ç©€é›œç³§ã€è”¬èœèˆ‡å„ªè³ªè›‹ç™½ã€‚",
    "petal-dance": "ç¹½ç´›è”¬æœå¯Œå«æ¤åŒ–ç´ ï¼ŒæŠ—æ°§åŒ–åŠ›ä¸€ç´šæ£’ï¼",
    "sunny-day": "æˆ¶å¤–æ´»å‹•æ›¬å¤ªé™½ï¼Œè£œå……ç¶­ç”Ÿç´ Då¹«åŠ©é•·é«˜ã€‚",
    
    "hydro-pump": "æ¯å¤©å–è¶³ 1500cc æ°´ï¼Œä¿ƒé€²é«”å…§å»¢ç‰©ä»£è¬ã€‚",
    "aqua-ring": "é£¯å‰å–æ°´èƒ½å¢åŠ é£½è¶³æ„Ÿï¼Œé¿å…æš´é£²æš´é£Ÿã€‚",
    "rain-dance": "é‹å‹•æµæ±—å¾Œï¼Œè¨˜å¾—è£œå……æ°´åˆ†èˆ‡é›»è§£è³ªã€‚",
    "protect": "æ‹’çµ•å«ç³–é£²æ–™ï¼Œä¿è­·èƒ°è‡Ÿï¼Œé é›¢ç³–å°¿ç—…ï¼",
    
    "aura-sphere": "å°ˆæ³¨ç•¶ä¸‹ï¼Œç´°åš¼æ…¢åš¥è®“å¤§è…¦æ¥æ”¶é£½è¶³è¨Šè™Ÿã€‚",
    "calm-mind": "å£“åŠ›å¤§æ™‚å®¹æ˜“æš´é£Ÿï¼Œæ·±å‘¼å¸æ”¾é¬†å¿ƒæƒ…ã€‚",
    "close-combat": "ç©æ¥µå°æŠ—æƒ³å·æ‡¶çš„å¿µé ­ï¼Œå»ºç«‹é‹å‹•ç¿’æ…£ï¼",
    "quick-attack": "æŠŠæ¡é›¶ç¢æ™‚é–“å‹•ä¸€å‹•ï¼Œç©å°‘æˆå¤šä¹Ÿèƒ½æ¶ˆè€—ç†±é‡ã€‚",

    // --- Enemy Moves (Health Warnings) ---
    // Sugar (Vanilluxe)
    "icicle-crash": "æ‰‹æ–é£²çš„æœç³–æœƒç›´æ¥å †ç©æˆè‚è‡Ÿè„‚è‚ªï¼",
    "sweet-scent": "ç”œå‘³æœƒè®“å¤§è…¦å¤šå·´èƒºä¸Šç™®ï¼Œè¶Šåƒè¶Šæƒ³åƒã€‚",
    "avalanche": "è¡€ç³–åƒé›²éœ„é£›è»Šå¿½é«˜å¿½ä½ï¼Œå®¹æ˜“ç–²å‹å—œç¡ã€‚",
    "blizzard": "éé‡å†°å“ç³–åˆ†ç†±é‡è¶…æ¨™ï¼Œå½±éŸ¿æ­£é¤é£Ÿæ…¾ã€‚",

    // Lazy (Snorlax)
    "yawn": "ä¹…åä¸å‹•æœƒè®“ä¸‹è‚¢è¡€æ¶²å¾ªç’°è®Šå·®ï¼Œä»£è¬è®Šæ…¢ã€‚",
    "rest": "ç¡å®Œåˆè¦ºé‚„æ˜¯ç´¯ï¼Ÿå¯èƒ½æ˜¯è‚¥èƒ–å°è‡´ç¡çœ å‘¼å¸ä¸­æ­¢ã€‚",
    "body-slam": "é«”é‡éé‡æœƒå°è†è“‹é—œç¯€é€ æˆå·¨å¤§è² æ“”ã€‚",
    "snore": "æ‰“å‘¼æ˜¯å‘¼å¸é“é˜»å¡è­¦è¨Šï¼Œå½±éŸ¿ç”Ÿé•·æ¿€ç´ åˆ†æ³Œã€‚",

    // Junk (Muk)
    "sludge-bomb": "æ²¹ç‚¸ç‰©ç”¢ç”Ÿè‡ªç”±åŸºï¼Œæ”»æ“Šé«”å…§æ­£å¸¸ç´°èƒã€‚",
    "gunk-shot": "éå¤šé£½å’Œè„‚è‚ªé…¸æœƒé˜»å¡è¡€ç®¡ï¼Œå¼•ç™¼å¿ƒè¡€ç®¡ç–¾ç—…ã€‚",
    "toxic": "åŠ å·¥è‚‰å“å«äºç¡é…¸é¹½ï¼Œæ˜¯è‡´ç™Œé¢¨éšªå› å­ã€‚",
    "belch": "ç‹¼åè™åš¥å®¹æ˜“è„¹æ°£æ¶ˆåŒ–ä¸è‰¯ï¼Œå¢åŠ è…¸èƒƒè² æ“”ã€‚",

    // Fallbacks
    "fighting": "é‹å‹•èƒ½å¼·åŒ–éª¨éª¼èˆ‡è‚Œè‚‰ï¼Œæå‡åŸºç¤ä»£è¬ç‡ï¼",
    "grass": "è”¬èœå¯Œå«è†³é£Ÿçº–ç¶­ï¼Œèƒ½å¢åŠ é£½è¶³æ„Ÿä¸¦ç©©å®šè¡€ç³–ï¼",
    "water": "å¤šå–æ°´å–ä»£å«ç³–é£²æ–™ï¼Œä¿ƒé€²æ–°é™³ä»£è¬ï¼",
    "poison": "åŠ å·¥é£Ÿå“èˆ‡åå¼è„‚è‚ªï¼Œæœƒé€ æˆèº«é«”æ…¢æ€§ç™¼ç‚ï¼",
    "ice": "é«˜æœç³–ç³–æ¼¿æœƒå°è‡´èƒ°å³¶ç´ é˜»æŠ—èˆ‡è„‚è‚ªè‚ï¼",
    "normal": "ä¹…åä¸å‹•è®“è„‚è‚ªå †ç©ï¼Œå¢åŠ å¿ƒè¡€ç®¡ç–¾ç—…é¢¨éšªï¼"
};

const ANIM_URL = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/";
const STATIC_URL = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/";

class BattleSystem {
    constructor() {
        this.pTeam = [];
        this.eTeam = [];
        this.pActive = 0;
        this.currentStageIdx = 0;
        this.state = 'LOADING'; 
        
        this.els = {
            dialogue: document.getElementById('dialogue-box'),
            moveMenu: document.getElementById('move-menu'),
            mainMenu: document.getElementById('main-menu'),
            partyMenu: document.getElementById('party-menu'),
            pSprite: document.getElementById('player-sprite'),
            eSprite: document.getElementById('enemy-sprite'),
            pHpBar: document.getElementById('p-hp-bar'),
            eHpBar: document.getElementById('e-hp-bar'),
            pHpText: document.getElementById('p-hp-cur'),
            pName: document.getElementById('p-name'),
            eName: document.getElementById('e-name'),
            scene: document.getElementById('battle-scene'),
            enemyHud: document.getElementById('enemy-hud'),
            playerHud: document.getElementById('player-hud'),
            loader: document.getElementById('loader'),
            canvas: document.getElementById('fx-canvas')
        };
        
        this.ctx = this.els.canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        this.init();
    }

    resizeCanvas() {
        this.els.canvas.width = this.els.canvas.offsetWidth;
        this.els.canvas.height = this.els.canvas.offsetHeight;
    }

    async init() {
        try {
            this.pTeam = await Promise.all(PLAYER_CONFIG.map(p => this.fetchPokemon(p)));
            this.els.loader.style.display = 'none';
            this.startAdventureStage(0);
        } catch (e) {
            console.error(e);
            this.els.loader.innerHTML = "è³‡æ–™è®€å–å¤±æ•—<br>è«‹æª¢æŸ¥ç¶²è·¯é€£ç·š";
        }
    }

    async fetchPokemon(config) {
        const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${config.id}`);
        const data = await res.json();
        
        const moves = await Promise.all(config.customMoves.map(async (mName) => {
            const mId = mName.toLowerCase().replace(' ', '-');
            const mRes = await fetch(`https://pokeapi.co/api/v2/move/${mId}`);
            const mData = await mRes.json();
            return {
                name: mData.names.find(n => n.language.name === 'zh-Hant')?.name || mName,
                type: mData.type.name,
                power: mData.power || 0,
                acc: mData.accuracy || 100,
                category: mData.damage_class.name,
                originalName: mId
            };
        }));

        return {
            name: config.name,
            role: config.role,
            spriteFront: `${ANIM_URL}${data.id}.gif`,
            spriteBack: `${ANIM_URL}back/${data.id}.gif`,
            spriteFrontStatic: `${STATIC_URL}${data.id}.png`,
            spriteBackStatic: `${STATIC_URL}back/${data.id}.png`,
            stats: {
                maxHp: data.stats[0].base_stat * 3,
                currentHp: data.stats[0].base_stat * 3,
                atk: data.stats[1].base_stat,
                def: data.stats[2].base_stat
            },
            types: data.types.map(t => t.type.name),
            moves: moves,
            fainted: false
        };
    }

    // --- Adventure Flow ---

    async startAdventureStage(idx) {
        if (idx >= STAGES.length) {
            this.typewriter("æ­å–œï¼ä½ æ“Šæ•—äº†æ‰€æœ‰è‚¥èƒ–é­”ç‹ï¼\nä½ ç¾åœ¨æ˜¯çœŸæ­£çš„å¥åº·å¤§å¸«ï¼");
            return;
        }

        this.currentStageIdx = idx;
        const stage = STAGES[idx];
        this.state = 'ADVENTURE';

        this.els.scene.className = stage.bg;
        this.els.enemyHud.style.opacity = 0;
        this.els.playerHud.style.opacity = 0;
        this.els.pSprite.style.opacity = 0;
        this.els.eSprite.style.opacity = 0;
        this.els.partyMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'none';

        this.typewriter(`${stage.name}\n${stage.intro}`);
        await this.wait(2500);

        try {
            this.typewriter("æ•µäººå‡ºç¾äº†ï¼");
            const enemy = await this.fetchPokemon(stage.enemyConfig);
            this.eTeam = [enemy];
            this.renderEnemy(enemy);
            await this.wait(1000);
            
            this.typewriter("è¦æ´¾èª°ä¸Šå ´æ‡‰æˆ°å‘¢ï¼Ÿ");
            await this.wait(1000);
            this.openPartyMenu(true);

        } catch(e) { console.error(e); }
    }

    renderEnemy(enemy) {
        this.els.eSprite.src = enemy.spriteFront;
        this.els.eSprite.onerror = () => { 
            this.els.eSprite.src = enemy.spriteFrontStatic; 
            this.els.eSprite.style.display = 'block';
        };
        
        this.els.eSprite.style.opacity = 1;
        this.els.enemyHud.style.opacity = 1;
        this.els.eName.innerText = enemy.name;
        this.updateHpBars(false);
        this.renderBadges('e-badges', [enemy.role === 'lazy' ? 'normal' : (enemy.role === 'sugar' ? 'ice' : 'poison')]); 
    }

    startBattle(playerPokemonIndex) {
        this.pActive = playerPokemonIndex;
        const p = this.pTeam[this.pActive];
        
        this.els.pSprite.src = p.spriteBack;
        this.els.pSprite.onerror = () => { 
            this.els.pSprite.src = p.spriteBackStatic; 
            this.els.pSprite.style.display = 'block';
        };

        this.els.pSprite.style.opacity = 1;
        this.els.playerHud.style.opacity = 1;
        
        this.renderPlayerHud();
        this.updateHpBars();
        
        this.state = 'BATTLE';
        this.els.partyMenu.style.display = 'none';
        this.toMainMenu();
        this.typewriter(`å°±æ±ºå®šæ˜¯ä½ äº†ï¼Œ${p.name}ï¼`);
    }

    // --- Party Menu ---

    openPartyMenu(isForced = false) {
        this.els.moveMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'none';
        this.els.partyMenu.style.display = 'flex';
        this.els.partyMenu.innerHTML = `<div class="party-title">${isForced ? 'é¸æ“‡å‡ºæˆ°ç²¾éˆ (å¿…é ˆé¸æ“‡)' : 'é¸æ“‡è¦æ›´æ›çš„ç²¾éˆ'}</div>`;

        this.pTeam.forEach((p, i) => {
            const slot = document.createElement('div');
            slot.className = `party-slot ${p.fainted ? 'fainted' : ''} ${i === this.pActive && !isForced && this.state === 'BATTLE' ? 'active' : ''}`;
            
            const hpPct = (p.stats.currentHp / p.stats.maxHp) * 100;
            const hpColor = this.getHpColor(hpPct);
            let roleText = "";
            if(p.role === 'fighting') roleText = "æ“…é•·ï¼šé‹å‹•";
            if(p.role === 'grass') roleText = "æ“…é•·ï¼šé£²é£Ÿæ§åˆ¶";
            if(p.role === 'water') roleText = "æ“…é•·ï¼šä»£è¬";

            slot.innerHTML = `
                <img src="${p.spriteFront}" style="width:50px;height:50px;object-fit:contain;">
                <div class="party-info">
                    <div>${p.name}</div>
                    <div style="font-weight:normal; font-size:10px; color:#666;">${roleText}</div>
                    <div class="party-hp-mini">
                        <div class="party-hp-fill" style="width:${hpPct}%; background:${hpColor}"></div>
                    </div>
                </div>
            `;

            slot.onclick = () => {
                if (p.fainted) return;
                if (i === this.pActive && this.state === 'BATTLE' && !isForced) {
                    this.typewriter(`${p.name} å·²ç¶“åœ¨å ´ä¸Šäº†ï¼`);
                    return;
                }
                
                if (this.state === 'ADVENTURE' || isForced) {
                    this.startBattle(i);
                } else if (this.state === 'BATTLE') {
                    this.performSwitchInBattle(i);
                }
            };
            this.els.partyMenu.appendChild(slot);
        });

        if (!isForced && this.state === 'BATTLE') {
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.innerText = 'å–æ¶ˆ';
            cancelBtn.style.marginTop = '15px';
            cancelBtn.onclick = () => {
                this.els.partyMenu.style.display = 'none';
                this.toMainMenu();
            };
            this.els.partyMenu.appendChild(cancelBtn);
        }
    }

    async performSwitchInBattle(newIndex) {
        this.els.partyMenu.style.display = 'none';
        this.state = 'BUSY';
        
        this.typewriter(`${this.pTeam[this.pActive].name}ï¼Œå›ä¾†å§ï¼`);
        this.els.pSprite.style.opacity = 0;
        await this.wait(1000);

        this.pActive = newIndex;
        const p = this.pTeam[this.pActive];
        this.els.pSprite.src = p.spriteBack;
        this.els.pSprite.onerror = () => { 
            this.els.pSprite.src = p.spriteBackStatic; 
            this.els.pSprite.style.display = 'block';
        };
        
        this.typewriter(`å»å§ï¼Œ${p.name}ï¼`);
        this.els.pSprite.style.opacity = 1;
        this.renderPlayerHud();
        this.updateHpBars();
        await this.wait(1000);

        this.enemyTurn();
    }

    // --- Battle Logic ---

    renderPlayerHud() {
        const p = this.pTeam[this.pActive];
        this.els.pName.innerText = p.name;
        this.renderBadges('p-badges', p.types);
        
        this.els.moveMenu.innerHTML = '';
        p.moves.forEach((m, idx) => {
            const btn = document.createElement('button');
            btn.className = `btn`;
            btn.innerHTML = `
                ${m.name}
                <div class="move-type-icon" style="color:${this.getTypeColor(m.type)}">
                    ${this.getTypeIcon(m.type)} ${m.type.toUpperCase()}
                </div>
            `;
            btn.style.borderColor = this.getTypeColor(m.type);
            btn.onclick = () => this.useMove(idx);
            this.els.moveMenu.appendChild(btn);
        });
        
        const backBtn = document.createElement('button');
        backBtn.className = 'btn';
        backBtn.innerText = 'â†© è¿”å›';
        backBtn.onclick = () => this.toMainMenu();
        this.els.moveMenu.appendChild(backBtn);
    }

    renderBadges(id, types) {
        const el = document.getElementById(id);
        const mapType = (t) => {
            if(t === 'normal') return 'ä¹…å';
            if(t === 'ice') return 'ç³–åˆ†';
            if(t === 'poison') return 'åƒåœ¾é£Ÿç‰©';
            if(t === 'fighting') return 'é‹å‹•';
            if(t === 'grass') return 'çº–ç¶­';
            if(t === 'water') return 'æ°´åˆ†';
            return t;
        };

        el.innerHTML = types.map(t => {
            const label = mapType(t);
            return `<span class="badge" style="background:${this.getTypeColor(t)}">${label}</span>`;
        }).join('');
    }

    updateHpBars(updatePlayer = true) {
        if (updatePlayer) {
            const p = this.pTeam[this.pActive];
            const pPct = (p.stats.currentHp / p.stats.maxHp) * 100;
            this.els.pHpBar.style.width = `${Math.max(0, pPct)}%`;
            this.els.pHpBar.style.backgroundColor = this.getHpColor(pPct);
            this.els.pHpText.innerText = Math.floor(Math.max(0, p.stats.currentHp));
        }
        
        if (this.eTeam.length > 0) {
            const e = this.eTeam[0];
            const ePct = (e.stats.currentHp / e.stats.maxHp) * 100;
            this.els.eHpBar.style.width = `${Math.max(0, ePct)}%`;
            this.els.eHpBar.style.backgroundColor = this.getHpColor(ePct);
        }
    }

    toMoveMenu() {
        if(this.state !== 'BATTLE') return;
        this.els.mainMenu.style.display = 'none';
        this.els.moveMenu.style.display = 'grid';
    }

    toMainMenu() {
        if(this.state !== 'BATTLE') return;
        this.els.moveMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'grid';
    }

    showBag() {
        this.typewriter("èƒŒåŒ…è£¡åªæœ‰æ°´å’Œè”¬èœæ£’ï¼\né€™äº›å·²ç¶“é€éæŠ€èƒ½ä½¿ç”¨å›‰ã€‚");
    }
    
    run() {
        this.typewriter("é¢å°å¥åº·å•é¡Œï¼Œ\nçµ•å°ä¸èƒ½é€ƒè·‘ï¼");
    }

    async useMove(moveIndex) {
        if (this.state !== 'BATTLE') return;
        this.state = 'BUSY';
        this.els.moveMenu.style.display = 'none';

        const attacker = this.pTeam[this.pActive];
        const defender = this.eTeam[0];
        const move = attacker.moves[moveIndex];

        await this.executeTurn(attacker, defender, move, true);

        if (defender.stats.currentHp <= 0) {
            await this.handleFaint(defender, false);
            return;
        }

        await this.enemyTurn();
    }

    async enemyTurn() {
        const attacker = this.eTeam[0];
        const defender = this.pTeam[this.pActive];
        
        if (attacker.stats.currentHp <= 0) return;

        await this.wait(1000);
        const eMove = attacker.moves[Math.floor(Math.random() * attacker.moves.length)];
        
        await this.executeTurn(attacker, defender, eMove, false);

        if (defender.stats.currentHp <= 0) {
            await this.handleFaint(defender, true);
        } else {
            this.state = 'BATTLE';
            this.toMainMenu();
            this.typewriter(`è¼ªåˆ° ${defender.name} è¡Œå‹•äº†ï¼`);
        }
    }

    async executeTurn(attacker, defender, move, isPlayer) {
        this.typewriter(`${attacker.name} ä½¿ç”¨äº† ã€${move.name}ã€‘ï¼`);
        await this.wait(1000);

        const sprite = isPlayer ? this.els.pSprite : this.els.eSprite;
        const targetSprite = isPlayer ? this.els.eSprite : this.els.pSprite;
        
        sprite.classList.add(isPlayer ? 'anim-attack-p' : 'anim-attack-e');
        this.createParticles(move.type, isPlayer);

        await this.wait(300);
        sprite.classList.remove('anim-attack-p', 'anim-attack-e');

        let effectiveness = 1.0;
        let effMessage = "";

        if (isPlayer) {
            const enemyRole = defender.role;
            const moveType = move.type;
            if (HEALTH_TYPE_CHART[enemyRole] && HEALTH_TYPE_CHART[enemyRole][moveType]) {
                effectiveness = HEALTH_TYPE_CHART[enemyRole][moveType];
            }
            if (effectiveness > 1) effMessage = "æ•ˆæœçµ•ä½³ï¼ (å°ç—‡ä¸‹è—¥)";
            if (effectiveness < 1) effMessage = "æ•ˆæœä¸å¥½... (æ–¹æ³•éŒ¯èª¤)";
        }

        let damage = (move.power * (attacker.stats.atk / defender.stats.def)) / 1.5;
        damage *= effectiveness;
        damage *= (0.85 + Math.random() * 0.15);
        if (move.category === 'status') damage = 0;
        
        defender.stats.currentHp -= damage;
        this.updateHpBars();

        if (damage > 0) {
            targetSprite.classList.add('anim-shake');
            await this.wait(500);
            targetSprite.classList.remove('anim-shake');
        }

        if (effMessage) {
            this.typewriter(effMessage);
            await this.wait(1500);
        }

        const eduMsg = EDU_TEXT[move.originalName] || EDU_TEXT[move.type];
        if (eduMsg) {
            this.typewriter(`${isPlayer ? 'ğŸ’¡ çŸ¥è­˜' : 'âš ï¸ è­¦è¨Š'}ï¼š\n${eduMsg}`);
            await this.wait(2000);
        }
    }

    async handleFaint(pokemon, isPlayer) {
        const sprite = isPlayer ? this.els.pSprite : this.els.eSprite;
        pokemon.fainted = true;
        this.typewriter(`${pokemon.name} å€’ä¸‹äº†ï¼`);
        sprite.classList.add('anim-faint');
        await this.wait(1500);
        sprite.classList.remove('anim-faint');
        sprite.style.opacity = 0;

        if (!isPlayer) {
            this.typewriter(`æˆåŠŸæ“Šé€€äº† ${pokemon.name}ï¼\nä¼‘æ¯ä¸€ä¸‹ï¼Œç¹¼çºŒå‰é€²...`);
            await this.wait(2000);
            this.startAdventureStage(this.currentStageIdx + 1);
        } else {
            const hasAlive = this.pTeam.some(p => !p.fainted);
            if (hasAlive) {
                this.typewriter("ä½ çš„ç²¾éˆå€’ä¸‹äº†ï¼Œè«‹é¸æ“‡ä¸‹ä¸€éš»ï¼");
                await this.wait(1000);
                this.openPartyMenu(true);
            } else {
                this.typewriter("ä½ çš„éšŠä¼å…¨è»è¦†æ²’...\nè«‹ä¼‘æ¯å¾Œé‡æ–°æŒ‘æˆ°ï¼");
                await this.wait(3000);
                location.reload();
            }
        }
    }

    // --- Utils ---
    getHpColor(pct) {
        if (pct > 50) return '#48c075';
        if (pct > 20) return '#f5ac38';
        return '#e64e4e';
    }

    getTypeColor(type) {
        const colors = {
            grass: '#78c850', fire: '#f08030', water: '#6890f0',
            normal: '#a8a878', fighting: '#c22e28', poison: '#a040a0',
            ice: '#98d8d8', ground: '#e0c068', flying: '#a890f0',
            psychic: '#f85888', bug: '#a8b820', rock: '#b8a038'
        };
        return colors[type] || '#aaa';
    }

    getTypeIcon(type) {
        const icons = { grass: 'ğŸŒ¿', fire: 'ğŸ”¥', water: 'ğŸ’§', fighting: 'ğŸ’ª', normal: 'âšª', poison: 'â˜ ï¸', ice: 'â„ï¸' };
        return icons[type] || 'âœ¨';
    }

    typewriter(text) {
        this.els.dialogue.innerHTML = '';
        let i = 0;
        clearInterval(this.typeInterval);
        this.typeInterval = setInterval(() => {
            this.els.dialogue.innerHTML += text.charAt(i);
            i++;
            if (i > text.length) clearInterval(this.typeInterval);
        }, 30);
    }
    
    advanceText() {
        // Placeholder
    }

    wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    createParticles(type, isPlayerToEnemy) {
        const color = this.getTypeColor(type);
        const startX = isPlayerToEnemy ? this.els.canvas.width * 0.2 : this.els.canvas.width * 0.8;
        const startY = isPlayerToEnemy ? this.els.canvas.height * 0.7 : this.els.canvas.height * 0.3;
        const endX = isPlayerToEnemy ? this.els.canvas.width * 0.8 : this.els.canvas.width * 0.2;
        const endY = isPlayerToEnemy ? this.els.canvas.height * 0.3 : this.els.canvas.height * 0.7;

        for(let i=0; i<15; i++) {
            setTimeout(() => {
                this.drawParticle(startX, startY, endX, endY, color);
            }, i * 30);
        }
    }

    drawParticle(x, y, tx, ty, color) {
        const p = {
            x: x + (Math.random()-0.5)*50,
            y: y + (Math.random()-0.5)*50,
            vx: (tx - x) / 20 + (Math.random()-0.5)*5,
            vy: (ty - y) / 20 + (Math.random()-0.5)*5,
            life: 1.0
        };

        const loop = () => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = p.life;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1.0;

            if (p.life > 0) requestAnimationFrame(loop);
            else this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height); 
        };
        loop();
    }
}

const battle = new BattleSystem();

</script>
</body>
</html>
