<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¥åº·å¤§å¸«ï¼šä»£è¬ä¹‹æˆ° - å†’éšªç¯‡</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #202020;
            --text-color: #333;
            --ui-bg: #f8f9fa;
            --ui-border: #4a4a4a;
            --hp-green: #48c075;
            --hp-yellow: #f5ac38;
            --hp-red: #e64e4e;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Press Start 2P', 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: var(--text-color);
            overflow: hidden;
        }

        #game-boy {
            width: 100%;
            max-width: 800px;
            height: 98vh;
            background: #d0d0d0;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            font-size: 16px;
        }

        #battle-scene {
            flex: 2;
            background-size: cover;
            background-position: center bottom;
            position: relative;
            transition: background 0.5s;
            overflow: hidden;
            border-bottom: 4px solid #333;
        }
        
        /* Backgrounds */
        .bg-park { background: linear-gradient(to bottom, #87CEEB 0%, #a8e063 100%); }
        .bg-forest { background: linear-gradient(to bottom, #56ab2f 0%, #a8e063 100%); }
        .bg-city { background: linear-gradient(to bottom, #2c3e50 0%, #bdc3c7 100%); }
        .bg-gym { background: linear-gradient(to bottom, #ff9966 0%, #ff5e62 100%); }

        .platform {
            position: absolute;
            width: 220px;
            height: 70px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            transform: scaleY(0.4);
            filter: blur(8px);
        }
        #enemy-platform { top: 35%; right: 10%; }
        #player-platform { bottom: 20%; left: 10%; }

        /* Sprite Base */
        .sprite {
            position: absolute;
            image-rendering: pixelated;
            transition: filter 0.2s, transform 0.2s, opacity 0.5s;
            opacity: 0;
            display: block; /* Ensure display is block by default */
            object-fit: contain;
        }
        
        #enemy-sprite {
            top: 15%; right: 12%; 
            height: 150px; width: 150px;
            z-index: 10;
        }

        #player-sprite {
            bottom: 22%; left: 12%; 
            height: 180px; width: 180px;
            z-index: 20;
        }

        /* Breathing Animation for Static Sprites (Gen 9) */
        .breathing {
            animation: breathe 2s infinite ease-in-out;
        }
        @keyframes breathe {
            0% { transform: scale(1); }
            50% { transform: scale(1.02) translateY(-2px); }
            100% { transform: scale(1); }
        }

        /* Battle Animations */
        .anim-shake { animation: shake 0.5s; }
        .anim-attack-p { animation: attack-lunge 0.2s; }
        .anim-attack-e { animation: enemy-lunge 0.2s; }
        .anim-faint { animation: faint 1s forwards; }

        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-10px) brightness(2) sepia(1) saturate(5) hue-rotate(-50deg); } 
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); filter: none;}
        }
        @keyframes attack-lunge { 0% { transform: translate(0,0); } 50% { transform: translate(40px, -40px); } 100% { transform: translate(0,0); } }
        @keyframes enemy-lunge { 0% { transform: translate(0,0); } 50% { transform: translate(-40px, 40px); } 100% { transform: translate(0,0); } }
        @keyframes faint { to { transform: translateY(50px); opacity: 0; } }

        /* HUD */
        .hud-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 4px solid #333;
            border-radius: 12px 2px 12px 2px;
            padding: 12px;
            width: 280px;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.2);
            transition: opacity 0.3s;
            z-index: 30;
        }
        #enemy-hud { top: 20px; left: 20px; }
        #player-hud { bottom: 20px; right: 20px; }

        .name-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 8px; font-weight: bold; }
        .hp-container {
            width: 100%; height: 16px; background: #ddd; border: 3px solid #333; border-radius: 8px; overflow: hidden;
        }
        .hp-bar { height: 100%; background: var(--hp-green); width: 100%; transition: width 0.5s ease-out, background-color 0.3s; }
        .hp-text { font-size: 12px; text-align: right; margin-top: 6px; font-weight: bold; }
        .status-badges { display: flex; gap: 5px; margin-top: 8px; flex-wrap: wrap; }
        .badge { font-size: 10px; padding: 4px 6px; color: white; border-radius: 4px; text-shadow: 1px 1px 0 #000; }

        /* UI Layer */
        #ui-layer {
            height: 280px; flex-shrink: 0; background: #222; padding: 15px; display: flex; flex-direction: column; gap: 10px; border-top: 6px solid #f8d030; position: relative;
        }
        #dialogue-box {
            background: #3a3a3a; color: white; border: 4px solid #fff; border-radius: 8px; padding: 15px; height: 100px; font-size: 16px; line-height: 1.5; position: relative; cursor: pointer; overflow-y: hidden;
        }
        #dialogue-box::after { content: 'â–¼'; position: absolute; bottom: 10px; right: 10px; animation: bounce 1s infinite; font-size: 20px; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(5px); } }

        #controls { display: flex; height: 120px; gap: 10px; }
        #main-menu, #move-menu { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; height: 100%; }
        
        .btn {
            background: #f8f9fa; border: 4px solid #4a4a4a; border-radius: 8px; font-family: 'Press Start 2P', sans-serif; font-size: 14px; cursor: pointer; text-align: center; display: flex; align-items: center; justify-content: center; flex-direction: column; padding: 5px; position: relative; box-shadow: 0 4px 0 #bbb; transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 0 #bbb; }
        .btn:hover { background: #e8e8e8; border-color: #e64e4e; }
        .move-type-icon { font-size: 10px; opacity: 0.7; margin-top: 5px; }
        #move-menu { display: none; }

        #party-menu {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(30, 30, 30, 0.95); padding: 20px; flex-direction: column; gap: 10px; z-index: 50; overflow-y: auto;
        }
        .party-slot {
            background: white; border: 4px solid #555; padding: 10px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; height: 70px;
        }
        .party-slot.active { border-color: #48bb78; background: #f0fff4; }
        .party-slot.fainted { background: #ccc; opacity: 0.7; }
        .party-info { font-size: 12px; flex: 1; margin-left: 15px; font-weight: bold; }
        .party-hp-mini { width: 100px; height: 8px; background: #eee; border: 2px solid #333; margin-top: 5px; border-radius: 5px; }
        .party-hp-fill { height: 100%; background: #48c075; width: 100%; }

        #fx-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%; background: #202020; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; font-size: 20px; text-align: center; line-height: 1.5;
        }
        .spinner { width: 50px; height: 50px; border: 5px solid #fff; border-top-color: transparent; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px;}
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="game-boy">
    <div id="loader">
        <div class="spinner"></div>
        <div>æ­£åœ¨é€£æ¥ PokÃ©API...</div>
        <div style="font-size: 14px; margin-top: 15px; color:#aaa;">é…ç½®ï¼šé­”å¹»å‡é¢å–µ & æ‡¶äººçº<br>è¼‰å…¥ç‰¹æ•ˆå¼•æ“...</div>
    </div>

    <canvas id="fx-canvas"></canvas>

    <div id="battle-scene" class="bg-forest">
        <!-- HUDs -->
        <div id="enemy-hud" class="hud-box" style="opacity:0;">
            <div class="name-row"><span id="e-name">...</span></div>
            <div class="hp-container"><div id="e-hp-bar" class="hp-bar"></div></div>
            <div class="status-badges" id="e-badges"></div>
        </div>

        <div id="player-hud" class="hud-box" style="opacity:0;">
            <div class="name-row"><span id="p-name">...</span></div>
            <div class="hp-container"><div id="p-hp-bar" class="hp-bar"></div></div>
            <div class="hp-text"><span id="p-hp-cur">0</span> / <span id="p-hp-max">0</span></div>
            <div class="status-badges" id="p-badges"></div>
        </div>

        <!-- REMOVED inline onerror to prevent accidental hiding -->
        <div class="platform" id="enemy-platform"></div>
        <img id="enemy-sprite" class="sprite" src="" alt="Enemy">
        
        <div class="platform" id="player-platform"></div>
        <img id="player-sprite" class="sprite" src="" alt="Player">
    </div>

    <div id="ui-layer">
        <div id="dialogue-box" onclick="battle.advanceText()">åˆå§‹åŒ–ä¸­...</div>

        <div id="controls">
            <div id="main-menu">
                <button class="btn" onclick="battle.toMoveMenu()">âš”ï¸ æˆ°é¬¥</button>
                <button class="btn" onclick="battle.showBag()">ğŸ’ èƒŒåŒ…</button>
                <button class="btn" onclick="battle.openPartyMenu(false)">ğŸ‘¥ ç²¾éˆ</button>
                <button class="btn" onclick="battle.run()">ğŸƒ é€ƒè·‘</button>
            </div>
            <div id="move-menu"></div>
            <div id="party-menu"></div>
        </div>
    </div>
</div>

<script>
/** * Game Data & Config 
 */
const PLAYER_CONFIG = [
    { 
        id: 68, name: "æ€ªåŠ› (é‹å‹•)", role: "fighting", 
        customMoves: ["Cross Chop", "Vital Throw", "Strength", "Bulk Up"] 
    },
    { 
        id: 908, name: "é­”å¹»å‡é¢å–µ (æ“‡é£Ÿ)", role: "grass", // Gen 9 Pokemon
        customMoves: ["Flower Trick", "Energy Ball", "Grassy Terrain", "Hone Claws"] 
    },
    { 
        id: 9, name: "æ°´ç®­é¾œ (æ°´åˆ†)", role: "water", 
        customMoves: ["Hydro Pump", "Aqua Ring", "Rain Dance", "Protect"] 
    },
    { 
        id: 448, name: "è·¯å¡åˆ©æ­ (è‡ªå¾‹)", role: "fighting", 
        customMoves: ["Aura Sphere", "Calm Mind", "Close Combat", "Quick Attack"] 
    }
];

const STAGES = [
    {
        name: "ç¬¬ä¸€é—œï¼šæ…µæ‡¶è‰åŸ",
        bg: "bg-park",
        intro: "é€™è£¡çš„ç©ºæ°£æ‡¶æ´‹æ´‹çš„ï¼Œå¤§å®¶éƒ½åªæƒ³èººè‘—...\nå°å¿ƒï¼æ‡¶æ•£æœƒå‚³æŸ“ï¼",
        enemyConfig: { id: 287, name: "æ‡¶äººçº (æ‡¶æ•£)", role: "lazy", customMoves: ["Slack Off", "Yawn", "Scratch", "Amnesia"] }
    },
    {
        name: "ç¬¬äºŒé—œï¼šç³–æœæ£®æ—",
        bg: "bg-forest",
        intro: "ç©ºæ°£ä¸­ç€°æ¼«è‘—ç”œè†©çš„å‘³é“...\nå°å¿ƒï¼ç³–ç™®æœƒå°è‡´èƒ°å³¶ç´ é˜»æŠ—ï¼",
        enemyConfig: { id: 584, name: "é›™å€å¤šå¤šå†° (ç³–ç™®)", role: "sugar", customMoves: ["Icicle Crash", "Sweet Scent", "Avalanche", "Blizzard"] }
    },
    {
        name: "ç¬¬ä¸‰é—œï¼šæ²™ç™¼å±±è°·",
        bg: "bg-gym",
        intro: "é€™è£¡çš„å±…æ°‘æ•´å¤©èººè‘—ä¸å‹•...\nä¹…åæ˜¯è¬ç—…ä¹‹æºï¼",
        enemyConfig: { id: 143, name: "å¡æ¯”ç¸ (ä¹…å)", role: "lazy", customMoves: ["Yawn", "Rest", "Body Slam", "Snore"] }
    },
    {
        name: "ç¬¬å››é—œï¼šåƒåœ¾æ©åŸ‹å ´",
        bg: "bg-city",
        intro: "å……æ»¿äº†åŠ å·¥é£Ÿå“å’Œæ²¹ç‚¸å‘³...\nåƒåœ¾é£Ÿç‰©æœƒé€ æˆèº«é«”ç™¼ç‚ï¼",
        enemyConfig: { id: 89, name: "è‡­è‡­æ³¥ (æ¯’ç´ )", role: "junk", customMoves: ["Sludge Bomb", "Gunk Shot", "Toxic", "Belch"] }
    }
];

// Health Logic Effectiveness (2.0 = Super Effective)
const HEALTH_TYPE_CHART = {
    'lazy': { 'fighting': 2.0, 'grass': 0.5, 'water': 0.5 }, // Exercise & Willpower beat Laziness
    'sugar': { 'water': 2.0, 'grass': 2.0, 'fighting': 1.0 }, // Water & Fiber beat Sugar
    'junk': { 'grass': 2.0, 'water': 1.5, 'fighting': 1.0 }   // Fiber beats Grease
};

const EDU_TEXT = {
    // Player Moves
    "cross-chop": "äº¤å‰è¨“ç·´èƒ½å…¨é¢æå‡å¿ƒè‚ºèˆ‡è‚Œè€åŠ›ï¼",
    "vital-throw": "æ ¸å¿ƒè‚Œç¾¤æ˜¯èº«é«”ç©©å®šçš„é—œéµï¼Œé¿å…å—å‚·ï¼",
    "strength": "è² é‡é‹å‹•èƒ½å¢åŠ éª¨è³ªå¯†åº¦ï¼Œé é˜²éª¨æŠ˜ã€‚",
    "bulk-up": "å¢åŠ è‚Œè‚‰é‡å¯æå‡åŸºç¤ä»£è¬ç‡ï¼Œèººè‘—ä¹Ÿç‡ƒè„‚ï¼",
    
    "flower-trick": "è®Šæ›ä¸åŒé¡è‰²çš„è”¬æœï¼Œæ”å–å¤šæ¨£åŒ–æ¤åŒ–ç´ ã€‚",
    "energy-ball": "å…¨ç©€æ ¹è–é¡æä¾›èº«é«”é•·æ•ˆçš„èƒ½é‡ä¾†æºã€‚",
    "grassy-terrain": "æ‰“é€ å®¶ä¸­ä¸æ”¾é›¶é£Ÿçš„ç’°å¢ƒï¼Œé™ä½èª˜æƒ‘ã€‚",
    "hone-claws": "æå‰æº–å‚™å¥½åˆ‡å¥½çš„æ°´æœï¼Œæƒ³åƒéš¨æ™‚æœ‰ã€‚",
    
    "hydro-pump": "æ¯å¤©å–è¶³ 1500cc æ°´ï¼Œä¿ƒé€²é«”å…§å»¢ç‰©ä»£è¬ã€‚",
    "aqua-ring": "é£¯å‰å–æ°´èƒ½å¢åŠ é£½è¶³æ„Ÿï¼Œé¿å…æš´é£²æš´é£Ÿã€‚",
    "rain-dance": "é‹å‹•æµæ±—å¾Œï¼Œè¨˜å¾—è£œå……æ°´åˆ†èˆ‡é›»è§£è³ªã€‚",
    "protect": "æ‹’çµ•å«ç³–é£²æ–™ï¼Œä¿è­·èƒ°è‡Ÿï¼Œé é›¢ç³–å°¿ç—…ï¼",
    
    "aura-sphere": "å°ˆæ³¨ç•¶ä¸‹ï¼Œç´°åš¼æ…¢åš¥è®“å¤§è…¦æ¥æ”¶é£½è¶³è¨Šè™Ÿã€‚",
    "calm-mind": "å£“åŠ›å¤§æ™‚å®¹æ˜“æš´é£Ÿï¼Œæ·±å‘¼å¸æ”¾é¬†å¿ƒæƒ…ã€‚",
    "close-combat": "ç©æ¥µå°æŠ—æƒ³å·æ‡¶çš„å¿µé ­ï¼Œå»ºç«‹é‹å‹•ç¿’æ…£ï¼",
    "quick-attack": "æŠŠæ¡é›¶ç¢æ™‚é–“å‹•ä¸€å‹•ï¼Œç©å°‘æˆå¤šä¹Ÿèƒ½æ¶ˆè€—ç†±é‡ã€‚",

    // Enemy Moves
    "slack-off": "èƒ½åå°±ä¸ç«™ï¼Œèƒ½èººå°±ä¸åï¼Œç†±é‡æ¶ˆè€—æ¥µä½ã€‚",
    "yawn": "ä¹…åä¸å‹•æœƒè®“ä¸‹è‚¢è¡€æ¶²å¾ªç’°è®Šå·®ï¼Œä»£è¬è®Šæ…¢ã€‚",
    "scratch": "ç„¡æ‰€äº‹äº‹ï¼Œç¼ºä¹ç”Ÿæ´»ç›®æ¨™èˆ‡å‹•åŠ›ã€‚",
    "amnesia": "å¿˜è¨˜äº†è¦é‹å‹•çš„æ‰¿è«¾ï¼Œæ˜å¤©å†èªªå§ã€‚",
    
    "icicle-crash": "æ‰‹æ–é£²çš„æœç³–æœƒç›´æ¥å †ç©æˆè‚è‡Ÿè„‚è‚ªï¼",
    "sweet-scent": "ç”œå‘³æœƒè®“å¤§è…¦å¤šå·´èƒºä¸Šç™®ï¼Œè¶Šåƒè¶Šæƒ³åƒã€‚",
    "avalanche": "è¡€ç³–åƒé›²éœ„é£›è»Šå¿½é«˜å¿½ä½ï¼Œå®¹æ˜“ç–²å‹å—œç¡ã€‚",
    "blizzard": "éé‡å†°å“ç³–åˆ†ç†±é‡è¶…æ¨™ï¼Œå½±éŸ¿æ­£é¤é£Ÿæ…¾ã€‚",

    "rest": "ç¡å®Œåˆè¦ºé‚„æ˜¯ç´¯ï¼Ÿå¯èƒ½æ˜¯è‚¥èƒ–å°è‡´ç¡çœ å‘¼å¸ä¸­æ­¢ã€‚",
    "body-slam": "é«”é‡éé‡æœƒå°è†è“‹é—œç¯€é€ æˆå·¨å¤§è² æ“”ã€‚",
    "snore": "æ‰“å‘¼æ˜¯å‘¼å¸é“é˜»å¡è­¦è¨Šï¼Œå½±éŸ¿ç”Ÿé•·æ¿€ç´ åˆ†æ³Œã€‚",

    "sludge-bomb": "æ²¹ç‚¸ç‰©ç”¢ç”Ÿè‡ªç”±åŸºï¼Œæ”»æ“Šé«”å…§æ­£å¸¸ç´°èƒã€‚",
    "gunk-shot": "éå¤šé£½å’Œè„‚è‚ªé…¸æœƒé˜»å¡è¡€ç®¡ï¼Œå¼•ç™¼å¿ƒè¡€ç®¡ç–¾ç—…ã€‚",
    "toxic": "åŠ å·¥è‚‰å“å«äºç¡é…¸é¹½ï¼Œæ˜¯è‡´ç™Œé¢¨éšªå› å­ã€‚",
    "belch": "ç‹¼åè™åš¥å®¹æ˜“è„¹æ°£æ¶ˆåŒ–ä¸è‰¯ï¼Œå¢åŠ è…¸èƒƒè² æ“”ã€‚"
};

// Map Move Categories to Visual Effects
const MOVE_VISUALS = {
    // Projectiles
    "aura-sphere": "projectile_blue", "sludge-bomb": "projectile_purple", "energy-ball": "projectile_green", 
    "gunk-shot": "projectile_purple", "toxic": "projectile_purple", "flower-trick": "projectile_green",
    
    // Beams / Streams
    "hydro-pump": "beam_blue", "blizzard": "beam_white", "icicle-crash": "beam_white", "giga-drain": "beam_green",
    
    // Physical / Impact
    "cross-chop": "impact_red", "vital-throw": "impact_red", "close-combat": "impact_red", "body-slam": "impact_white",
    "quick-attack": "impact_white", "strength": "impact_white", "scratch": "impact_white", "avalanche": "impact_white",
    
    // Buffs / Status
    "bulk-up": "buff_red", "calm-mind": "buff_pink", "synthesis": "buff_green", "aqua-ring": "buff_blue",
    "protect": "buff_blue", "rest": "buff_pink", "slack-off": "buff_pink", "yawn": "buff_white", "hone-claws": "buff_red",
    
    // Weather / Field
    "rain-dance": "weather_rain", "sunny-day": "weather_sun", "grassy-terrain": "weather_leaf", "sweet-scent": "weather_pink"
};

const ANIM_URL = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/";
const STATIC_URL = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/";

class BattleSystem {
    constructor() {
        this.pTeam = [];
        this.eTeam = [];
        this.pActive = 0;
        this.currentStageIdx = 0;
        this.state = 'LOADING'; 
        
        this.els = {
            dialogue: document.getElementById('dialogue-box'),
            moveMenu: document.getElementById('move-menu'),
            mainMenu: document.getElementById('main-menu'),
            partyMenu: document.getElementById('party-menu'),
            pSprite: document.getElementById('player-sprite'),
            eSprite: document.getElementById('enemy-sprite'),
            pHpBar: document.getElementById('p-hp-bar'),
            eHpBar: document.getElementById('e-hp-bar'),
            pHpText: document.getElementById('p-hp-cur'),
            pName: document.getElementById('p-name'),
            eName: document.getElementById('e-name'),
            scene: document.getElementById('battle-scene'),
            enemyHud: document.getElementById('enemy-hud'),
            playerHud: document.getElementById('player-hud'),
            loader: document.getElementById('loader'),
            canvas: document.getElementById('fx-canvas')
        };
        
        this.ctx = this.els.canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        this.init();
    }

    resizeCanvas() {
        this.els.canvas.width = this.els.canvas.offsetWidth;
        this.els.canvas.height = this.els.canvas.offsetHeight;
    }

    async init() {
        try {
            this.pTeam = await Promise.all(PLAYER_CONFIG.map(p => this.fetchPokemon(p)));
            this.els.loader.style.display = 'none';
            this.startAdventureStage(0);
        } catch (e) {
            console.error(e);
            this.els.loader.innerHTML = "è³‡æ–™è®€å–å¤±æ•—<br>è«‹æª¢æŸ¥ç¶²è·¯é€£ç·š";
        }
    }

    async fetchPokemon(config) {
        const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${config.id}`);
        const data = await res.json();
        
        const moves = await Promise.all(config.customMoves.map(async (mName) => {
            const mId = mName.toLowerCase().replace(' ', '-');
            const mRes = await fetch(`https://pokeapi.co/api/v2/move/${mId}`);
            const mData = await mRes.json();
            return {
                name: mData.names.find(n => n.language.name === 'zh-Hant')?.name || mName,
                type: mData.type.name,
                power: mData.power || 0,
                acc: mData.accuracy || 100,
                category: mData.damage_class.name,
                originalName: mId
            };
        }));

        // Handle Sprite: Use Animated for Gen 5-, Static for Gen 6+ (Meowscarada is 908)
        let sFront, sBack;
        if (config.id > 649) {
            sFront = data.sprites.front_default;
            sBack = data.sprites.back_default;
        } else {
            sFront = `${ANIM_URL}${data.id}.gif`;
            sBack = `${ANIM_URL}back/${data.id}.gif`;
        }

        return {
            name: config.name,
            role: config.role,
            isGen5Plus: config.id > 649,
            spriteFront: sFront,
            spriteBack: sBack,
            // Fallbacks
            spriteFrontStatic: data.sprites.front_default,
            spriteBackStatic: data.sprites.back_default,
            stats: {
                maxHp: data.stats[0].base_stat * 3,
                currentHp: data.stats[0].base_stat * 3,
                atk: data.stats[1].base_stat,
                def: data.stats[2].base_stat
            },
            types: data.types.map(t => t.type.name),
            moves: moves,
            fainted: false
        };
    }

    // --- Visual Effects Engine ---
    playMoveVisual(moveName, type, isPlayer) {
        const effect = MOVE_VISUALS[moveName] || (type === 'grass' ? 'buff_green' : 'impact_white');
        const [style, colorName] = effect.split('_');
        
        const startX = isPlayer ? this.els.canvas.width * 0.2 : this.els.canvas.width * 0.8;
        const startY = isPlayer ? this.els.canvas.height * 0.6 : this.els.canvas.height * 0.3;
        const targetX = isPlayer ? this.els.canvas.width * 0.8 : this.els.canvas.width * 0.2;
        const targetY = isPlayer ? this.els.canvas.height * 0.3 : this.els.canvas.height * 0.6;

        let color = '#fff';
        if(colorName === 'red') color = '#e74c3c';
        if(colorName === 'blue') color = '#3498db';
        if(colorName === 'green') color = '#2ecc71';
        if(colorName === 'purple') color = '#9b59b6';
        if(colorName === 'pink') color = '#ff9ff3';
        if(colorName === 'white') color = '#ffffff';

        if (style === 'projectile') this.animProjectile(startX, startY, targetX, targetY, color);
        else if (style === 'beam') this.animBeam(startX, startY, targetX, targetY, color);
        else if (style === 'impact') this.animImpact(targetX, targetY, color);
        else if (style === 'buff') this.animBuff(startX, startY, color);
        else if (style === 'weather') this.animWeather(colorName);
    }

    animProjectile(x, y, tx, ty, color) {
        let t = 0;
        const loop = () => {
            t += 0.05;
            const cx = x + (tx - x) * t;
            const cy = y + (ty - y) * t - Math.sin(t * Math.PI) * 100; // Arc
            
            this.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, 15, 0, Math.PI * 2);
            this.ctx.fillStyle = color;
            this.ctx.fill();
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = color;

            if (t < 1) requestAnimationFrame(loop);
            else {
                this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
                this.animImpact(tx, ty, color); // Impact on land
            }
        };
        loop();
    }

    animBeam(x, y, tx, ty, color) {
        let w = 0;
        const loop = () => {
            w += 20;
            this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
            
            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(tx, ty);
            this.ctx.lineWidth = w > 50 ? 100 - w : w;
            this.ctx.strokeStyle = color;
            this.ctx.lineCap = 'round';
            this.ctx.globalAlpha = 0.8;
            this.ctx.stroke();
            this.ctx.globalAlpha = 1.0;

            if (w < 100) requestAnimationFrame(loop);
            else this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
        };
        loop();
    }

    animImpact(x, y, color) {
        let r = 0;
        const loop = () => {
            r += 5;
            this.ctx.globalCompositeOperation = 'lighter';
            this.ctx.beginPath();
            this.ctx.arc(x, y, r, 0, Math.PI*2);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 1 - (r/60);
            this.ctx.fill();
            
            // Spikes
            for(let i=0; i<8; i++) {
                this.ctx.beginPath();
                const ang = (i/8)*Math.PI*2;
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + Math.cos(ang)*r*1.5, y + Math.sin(ang)*r*1.5);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
            }

            this.ctx.globalAlpha = 1.0;
            this.ctx.globalCompositeOperation = 'source-over';

            if (r < 60) requestAnimationFrame(loop);
            else this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
        };
        loop();
    }

    animBuff(x, y, color) {
        let particles = [];
        for(let i=0; i<10; i++) particles.push({x: x-30+Math.random()*60, y: y, vy: 1+Math.random()*2, life: 1});
        
        const loop = () => {
            this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
            let alive = false;
            particles.forEach(p => {
                p.y -= p.vy;
                p.life -= 0.02;
                if(p.life > 0) {
                    alive = true;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
            });
            this.ctx.globalAlpha = 1.0;
            if(alive) requestAnimationFrame(loop);
        };
        loop();
    }

    animWeather(type) {
        // Simple overlay fade
        let t = 0;
        let color = type === 'rain' ? 'rgba(0,0,100,0.3)' : (type === 'sun' ? 'rgba(255,200,0,0.3)' : 'rgba(0,255,0,0.2)');
        const loop = () => {
            t += 0.05;
            this.ctx.clearRect(0,0,this.els.canvas.width, this.els.canvas.height);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = Math.sin(t*Math.PI);
            this.ctx.fillRect(0,0,this.els.canvas.width, this.els.canvas.height);
            this.ctx.globalAlpha = 1.0;
            if(t < 1) requestAnimationFrame(loop);
        };
        loop();
    }

    // --- Game Logic ---

    async startAdventureStage(idx) {
        if (idx >= STAGES.length) {
            this.typewriter("æ­å–œï¼ä½ æ“Šæ•—äº†æ‰€æœ‰è‚¥èƒ–é­”ç‹ï¼\nä½ ç¾åœ¨æ˜¯çœŸæ­£çš„å¥åº·å¤§å¸«ï¼");
            return;
        }

        this.currentStageIdx = idx;
        const stage = STAGES[idx];
        this.state = 'ADVENTURE';

        this.els.scene.className = stage.bg;
        this.els.enemyHud.style.opacity = 0;
        this.els.playerHud.style.opacity = 0;
        this.els.pSprite.style.opacity = 0;
        this.els.eSprite.style.opacity = 0;
        this.els.partyMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'none';

        this.typewriter(`${stage.name}\n${stage.intro}`);
        await this.wait(2500);

        try {
            this.typewriter("æ•µäººå‡ºç¾äº†ï¼");
            const enemy = await this.fetchPokemon(stage.enemyConfig);
            this.eTeam = [enemy];
            this.renderEnemy(enemy);
            await this.wait(1000);
            
            this.typewriter("è¦æ´¾èª°ä¸Šå ´æ‡‰æˆ°å‘¢ï¼Ÿ");
            await this.wait(1000);
            this.openPartyMenu(true);

        } catch(e) { console.error(e); }
    }

    renderEnemy(enemy) {
        this.els.eSprite.style.display = 'block'; // Force display to prevent hidden state
        this.els.eSprite.src = enemy.spriteFront;
        this.els.eSprite.onerror = () => { 
            this.els.eSprite.src = enemy.spriteFrontStatic; 
            this.els.eSprite.style.display = 'block';
        };
        
        // Apply breathing class if static sprite (Gen 9)
        if(enemy.isGen5Plus) this.els.eSprite.classList.add('breathing');
        else this.els.eSprite.classList.remove('breathing');

        this.els.eSprite.style.opacity = 1;
        this.els.enemyHud.style.opacity = 1;
        this.els.eName.innerText = enemy.name;
        this.updateHpBars(false);
        this.renderBadges('e-badges', [enemy.role === 'lazy' ? 'normal' : (enemy.role === 'sugar' ? 'ice' : 'poison')]); 
    }

    startBattle(playerPokemonIndex) {
        this.pActive = playerPokemonIndex;
        const p = this.pTeam[this.pActive];
        
        this.els.pSprite.style.display = 'block'; // Force display
        this.els.pSprite.src = p.spriteBack;
        this.els.pSprite.onerror = () => { 
            this.els.pSprite.src = p.spriteBackStatic; 
            this.els.pSprite.style.display = 'block';
        };
        
        if(p.isGen5Plus) this.els.pSprite.classList.add('breathing');
        else this.els.pSprite.classList.remove('breathing');

        this.els.pSprite.style.opacity = 1;
        this.els.playerHud.style.opacity = 1;
        
        this.renderPlayerHud();
        this.updateHpBars();
        
        this.state = 'BATTLE';
        this.els.partyMenu.style.display = 'none';
        this.toMainMenu();
        this.typewriter(`å°±æ±ºå®šæ˜¯ä½ äº†ï¼Œ${p.name}ï¼`);
    }

    openPartyMenu(isForced = false) {
        this.els.moveMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'none';
        this.els.partyMenu.style.display = 'flex';
        this.els.partyMenu.innerHTML = `<div class="party-title">${isForced ? 'é¸æ“‡å‡ºæˆ°ç²¾éˆ' : 'æ›´æ›ç²¾éˆ'}</div>`;

        this.pTeam.forEach((p, i) => {
            const slot = document.createElement('div');
            slot.className = `party-slot ${p.fainted ? 'fainted' : ''} ${i === this.pActive && !isForced && this.state === 'BATTLE' ? 'active' : ''}`;
            const hpPct = (p.stats.currentHp / p.stats.maxHp) * 100;
            const hpColor = this.getHpColor(hpPct);
            let roleText = "";
            if(p.role === 'fighting') roleText = "æ“…é•·ï¼šé‹å‹•/è‡ªå¾‹";
            if(p.role === 'grass') roleText = "æ“…é•·ï¼šé£²é£Ÿæ§åˆ¶";
            if(p.role === 'water') roleText = "æ“…é•·ï¼šä»£è¬";

            slot.innerHTML = `
                <img src="${p.spriteFront}" style="width:50px;height:50px;object-fit:contain;">
                <div class="party-info">
                    <div>${p.name}</div>
                    <div style="font-weight:normal; font-size:10px; color:#666;">${roleText}</div>
                    <div class="party-hp-mini">
                        <div class="party-hp-fill" style="width:${hpPct}%; background:${hpColor}"></div>
                    </div>
                </div>
            `;
            slot.onclick = () => {
                if (p.fainted) return;
                if (i === this.pActive && this.state === 'BATTLE' && !isForced) {
                    this.typewriter(`${p.name} å·²ç¶“åœ¨å ´ä¸Šäº†ï¼`);
                    return;
                }
                if (this.state === 'ADVENTURE' || isForced) this.startBattle(i);
                else if (this.state === 'BATTLE') this.performSwitchInBattle(i);
            };
            this.els.partyMenu.appendChild(slot);
        });

        if (!isForced && this.state === 'BATTLE') {
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.innerText = 'å–æ¶ˆ';
            cancelBtn.style.marginTop = '15px';
            cancelBtn.onclick = () => {
                this.els.partyMenu.style.display = 'none';
                this.toMainMenu();
            };
            this.els.partyMenu.appendChild(cancelBtn);
        }
    }

    async performSwitchInBattle(newIndex) {
        this.els.partyMenu.style.display = 'none';
        this.state = 'BUSY';
        this.typewriter(`${this.pTeam[this.pActive].name}ï¼Œå›ä¾†å§ï¼`);
        this.els.pSprite.style.opacity = 0;
        await this.wait(1000);
        this.pActive = newIndex;
        this.startBattle(newIndex); // Reuses render logic
        await this.wait(1000);
        this.enemyTurn();
    }

    renderPlayerHud() {
        const p = this.pTeam[this.pActive];
        this.els.pName.innerText = p.name;
        this.renderBadges('p-badges', p.types);
        this.els.moveMenu.innerHTML = '';
        p.moves.forEach((m, idx) => {
            const btn = document.createElement('button');
            btn.className = `btn`;
            btn.innerHTML = `${m.name}<div class="move-type-icon" style="color:${this.getTypeColor(m.type)}">${this.getTypeIcon(m.type)} ${m.type.toUpperCase()}</div>`;
            btn.style.borderColor = this.getTypeColor(m.type);
            btn.onclick = () => this.useMove(idx);
            this.els.moveMenu.appendChild(btn);
        });
        const backBtn = document.createElement('button');
        backBtn.className = 'btn';
        backBtn.innerText = 'â†© è¿”å›';
        backBtn.onclick = () => this.toMainMenu();
        this.els.moveMenu.appendChild(backBtn);
    }

    renderBadges(id, types) {
        const el = document.getElementById(id);
        const mapType = (t) => {
            if(t === 'normal') return 'ä¹…å'; if(t === 'ice') return 'ç³–åˆ†';
            if(t === 'poison') return 'åƒåœ¾é£Ÿç‰©'; if(t === 'fighting') return 'é‹å‹•';
            if(t === 'grass') return 'çº–ç¶­'; if(t === 'water') return 'æ°´åˆ†';
            return t;
        };
        el.innerHTML = types.map(t => `<span class="badge" style="background:${this.getTypeColor(t)}">${mapType(t)}</span>`).join('');
    }

    updateHpBars(updatePlayer = true) {
        if (updatePlayer) {
            const p = this.pTeam[this.pActive];
            const pPct = (p.stats.currentHp / p.stats.maxHp) * 100;
            this.els.pHpBar.style.width = `${Math.max(0, pPct)}%`;
            this.els.pHpBar.style.backgroundColor = this.getHpColor(pPct);
            this.els.pHpText.innerText = Math.floor(Math.max(0, p.stats.currentHp));
        }
        if (this.eTeam.length > 0) {
            const e = this.eTeam[0];
            const ePct = (e.stats.currentHp / e.stats.maxHp) * 100;
            this.els.eHpBar.style.width = `${Math.max(0, ePct)}%`;
            this.els.eHpBar.style.backgroundColor = this.getHpColor(ePct);
        }
    }

    toMoveMenu() {
        if(this.state !== 'BATTLE') return;
        this.els.mainMenu.style.display = 'none';
        this.els.moveMenu.style.display = 'grid';
    }

    toMainMenu() {
        if(this.state !== 'BATTLE') return;
        this.els.moveMenu.style.display = 'none';
        this.els.mainMenu.style.display = 'grid';
    }

    showBag() { this.typewriter("èƒŒåŒ…è£¡åªæœ‰æ°´å’Œè”¬èœæ£’ï¼\né€™äº›å·²ç¶“é€éæŠ€èƒ½ä½¿ç”¨å›‰ã€‚"); }
    run() { this.typewriter("é¢å°å¥åº·å•é¡Œï¼Œ\nçµ•å°ä¸èƒ½é€ƒè·‘ï¼"); }

    async useMove(moveIndex) {
        if (this.state !== 'BATTLE') return;
        this.state = 'BUSY';
        this.els.moveMenu.style.display = 'none';
        const attacker = this.pTeam[this.pActive];
        const defender = this.eTeam[0];
        const move = attacker.moves[moveIndex];
        await this.executeTurn(attacker, defender, move, true);
        if (defender.stats.currentHp <= 0) { await this.handleFaint(defender, false); return; }
        await this.enemyTurn();
    }

    async enemyTurn() {
        const attacker = this.eTeam[0];
        const defender = this.pTeam[this.pActive];
        if (attacker.stats.currentHp <= 0) return;
        await this.wait(1000);
        const eMove = attacker.moves[Math.floor(Math.random() * attacker.moves.length)];
        await this.executeTurn(attacker, defender, eMove, false);
        if (defender.stats.currentHp <= 0) { await this.handleFaint(defender, true); }
        else { this.state = 'BATTLE'; this.toMainMenu(); this.typewriter(`è¼ªåˆ° ${defender.name} è¡Œå‹•äº†ï¼`); }
    }

    async executeTurn(attacker, defender, move, isPlayer) {
        this.typewriter(`${attacker.name} ä½¿ç”¨äº† ã€${move.name}ã€‘ï¼`);
        await this.wait(800);

        const sprite = isPlayer ? this.els.pSprite : this.els.eSprite;
        const targetSprite = isPlayer ? this.els.eSprite : this.els.pSprite;
        
        sprite.classList.add(isPlayer ? 'anim-attack-p' : 'anim-attack-e');
        // Play Unique Visual
        this.playMoveVisual(move.originalName, move.type, isPlayer);
        await this.wait(300);
        sprite.classList.remove('anim-attack-p', 'anim-attack-e');

        let effectiveness = 1.0;
        let effMessage = "";

        if (isPlayer) {
            const enemyRole = defender.role;
            const moveType = move.type;
            if (HEALTH_TYPE_CHART[enemyRole] && HEALTH_TYPE_CHART[enemyRole][moveType]) {
                effectiveness = HEALTH_TYPE_CHART[enemyRole][moveType];
            }
            if (effectiveness > 1) effMessage = "æ•ˆæœçµ•ä½³ï¼ (å°ç—‡ä¸‹è—¥)";
            if (effectiveness < 1) effMessage = "æ•ˆæœä¸å¥½... (æ–¹æ³•éŒ¯èª¤)";
        }

        let damage = (move.power * (attacker.stats.atk / defender.stats.def)) / 1.5;
        damage *= effectiveness;
        damage *= (0.85 + Math.random() * 0.15);
        if (move.category === 'status') damage = 0;
        
        defender.stats.currentHp -= damage;
        this.updateHpBars();

        if (damage > 0) {
            targetSprite.classList.add('anim-shake');
            await this.wait(500);
            targetSprite.classList.remove('anim-shake');
        }

        if (effMessage) {
            this.typewriter(effMessage);
            await this.wait(1500);
        }

        const eduMsg = EDU_TEXT[move.originalName] || EDU_TEXT[move.type];
        if (eduMsg) {
            this.typewriter(`${isPlayer ? 'ğŸ’¡ çŸ¥è­˜' : 'âš ï¸ è­¦è¨Š'}ï¼š\n${eduMsg}`);
            await this.wait(2000);
        }
    }

    async handleFaint(pokemon, isPlayer) {
        const sprite = isPlayer ? this.els.pSprite : this.els.eSprite;
        pokemon.fainted = true;
        this.typewriter(`${pokemon.name} å€’ä¸‹äº†ï¼`);
        sprite.classList.add('anim-faint');
        await this.wait(1500);
        sprite.classList.remove('anim-faint');
        sprite.style.opacity = 0;

        if (!isPlayer) {
            this.typewriter(`æˆåŠŸæ“Šé€€äº† ${pokemon.name}ï¼\nç¹¼çºŒå‰é€²...`);
            await this.wait(2000);
            this.startAdventureStage(this.currentStageIdx + 1);
        } else {
            const hasAlive = this.pTeam.some(p => !p.fainted);
            if (hasAlive) {
                this.typewriter("è«‹é¸æ“‡ä¸‹ä¸€éš»ç²¾éˆï¼");
                await this.wait(1000);
                this.openPartyMenu(true);
            } else {
                this.typewriter("å…¨è»è¦†æ²’...\nè«‹é‡æ–°æŒ‘æˆ°ï¼");
                await this.wait(3000);
                location.reload();
            }
        }
    }

    // Utils
    getHpColor(pct) { if (pct > 50) return '#48c075'; if (pct > 20) return '#f5ac38'; return '#e64e4e'; }
    getTypeColor(type) {
        const colors = { grass: '#78c850', fire: '#f08030', water: '#6890f0', normal: '#a8a878', fighting: '#c22e28', poison: '#a040a0', ice: '#98d8d8' };
        return colors[type] || '#aaa';
    }
    getTypeIcon(type) {
        const icons = { grass: 'ğŸŒ¿', fire: 'ğŸ”¥', water: 'ğŸ’§', fighting: 'ğŸ’ª', normal: 'âšª', poison: 'â˜ ï¸', ice: 'â„ï¸' };
        return icons[type] || 'âœ¨';
    }
    typewriter(text) {
        this.els.dialogue.innerHTML = '';
        let i = 0;
        clearInterval(this.typeInterval);
        this.typeInterval = setInterval(() => {
            this.els.dialogue.innerHTML += text.charAt(i);
            i++;
            if (i > text.length) clearInterval(this.typeInterval);
        }, 30);
    }
    advanceText() { /* optional skip */ }
    wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
}

const battle = new BattleSystem();
</script>
</body>
</html>
